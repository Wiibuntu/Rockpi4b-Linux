--- drivers/usb/core/message.c
+++ drivers/usb/core/message.c
@@ -147,6 +147,10 @@ int usb_control_msg(struct usb_device *dev, unsigned int pipe, __u8 request,
 
 	ret = usb_internal_control_msg(dev, pipe, dr, data, size, timeout);
 
+	/* Linger a bit, prior to the next control message. */
+	if (dev->quirks & USB_QUIRK_DELAY_CTRL_MSG)
+		msleep(200);
+
 	kfree(dr);
 
 	return ret;
@@ -1144,7 +1148,7 @@ void usb_disable_interface(struct usb_device *dev, struct usb_interface *intf,
  */
 void usb_disable_device(struct usb_device *dev, int skip_ep0)
 {
-	int i;
+	int i, j;
 	struct usb_hcd *hcd = bus_to_hcd(dev->bus);
 
 	/* getting rid of interfaces will disconnect
@@ -1169,6 +1173,27 @@ void usb_disable_device(struct usb_device *dev, int skip_ep0)
 			dev_dbg(&dev->dev, "unregistering interface %s\n",
 				dev_name(&interface->dev));
 			remove_intf_ep_devs(interface);
+
+			/*
+			 * Some special SoCs (e.g. rk322xh) USB 3.0 module
+			 * can't handle outstanding URBs by hardware when
+			 * when USB 3.0 device disconnect, so we need to
+			 * cancel all URBs pending on this device here.
+			 *
+			 * In addition, we just reuse the hub autosuspend
+			 * quirk but not add a new quirk for this issue.
+			 * Because it always occurs with autosuspend issue.
+			 */
+			if (hcd->self.root_hub->quirks &
+			    USB_QUIRK_AUTO_SUSPEND) {
+				for (j = skip_ep0; j < 16; ++j) {
+					usb_hcd_flush_endpoint(dev,
+							       dev->ep_out[j]);
+					usb_hcd_flush_endpoint(dev,
+							       dev->ep_in[j]);
+				}
+			}
+
 			device_del(&interface->dev);
 		}
 
@@ -1278,6 +1303,11 @@ void usb_enable_interface(struct usb_device *dev,
  * is submitted that needs that bandwidth.  Some other operating systems
  * allocate bandwidth early, when a configuration is chosen.
  *
+ * xHCI reserves bandwidth and configures the alternate setting in
+ * usb_hcd_alloc_bandwidth(). If it fails the original interface altsetting
+ * may be disabled. Drivers cannot rely on any particular alternate
+ * setting being in effect after a failure.
+ *
  * This call is synchronous, and may not be used in an interrupt context.
  * Also, drivers must not change altsettings while urbs are scheduled for
  * endpoints in that interface; all such urbs must first be completed
@@ -1313,6 +1343,12 @@ int usb_set_interface(struct usb_device *dev, int interface, int alternate)
 			 alternate);
 		return -EINVAL;
 	}
+	/*
+	 * usb3 hosts configure the interface in usb_hcd_alloc_bandwidth,
+	 * including freeing dropped endpoint ring buffers.
+	 * Make sure the interface endpoints are flushed before that
+	 */
+	usb_disable_interface(dev, iface, false);
 
 	/* Make sure we have enough bandwidth for this alternate interface.
 	 * Remove the current alt setting and add the new alt setting.
