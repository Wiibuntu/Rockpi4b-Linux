--- drivers/tty/serial/8250/8250_dma.c
+++ drivers/tty/serial/8250/8250_dma.c
@@ -107,19 +149,26 @@ static void __dma_rx_complete(void *param)
 	tty_flip_buffer_push(tty_port);
 }
 
+#endif
+
 int serial8250_tx_dma(struct uart_8250_port *p)
 {
 	struct uart_8250_dma		*dma = p->dma;
 	struct circ_buf			*xmit = &p->port.state->xmit;
 	struct dma_async_tx_descriptor	*desc;
-	int ret;
+	int ret = 0;
 
 	if (uart_tx_stopped(&p->port) || dma->tx_running ||
 	    uart_circ_empty(xmit))
 		return 0;
 
 	dma->tx_size = CIRC_CNT_TO_END(xmit->head, xmit->tail, UART_XMIT_SIZE);
-
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if (dma->tx_size < MAX_TX_BYTES) {
+		ret = -EBUSY;
+		goto err;
+	}
+#endif
 	desc = dmaengine_prep_slave_single(dma->txchan,
 					   dma->tx_addr + xmit->tail,
 					   dma->tx_size, DMA_MEM_TO_DEV,
@@ -155,6 +207,68 @@ err:
 	return ret;
 }
 
+#ifdef CONFIG_ARCH_ROCKCHIP
+
+int serial8250_rx_dma(struct uart_8250_port *p, unsigned int iir)
+{
+	unsigned int rfl, i = 0, fcr = 0, cur_index = 0;
+	unsigned char buf[MAX_FIFO_SIZE];
+	struct uart_port	*port = &p->port;
+	struct tty_port		*tty_port = &p->port.state->port;
+	struct dma_tx_state	state;
+	struct uart_8250_dma	*dma = p->dma;
+
+
+	if ((iir & 0xf) != UART_IIR_RX_TIMEOUT)
+		return 0;
+
+	fcr = UART_FCR_ENABLE_FIFO | UART_FCR_T_TRIG_10 | UART_FCR_R_TRIG_11;
+	serial_port_out(port, UART_FCR, fcr);
+
+	do {
+		dmaengine_tx_status(dma->rxchan, dma->rx_cookie, &state);
+		cur_index = dma->rx_size - state.residue;
+	} while (cur_index % dma->rxconf.src_maxburst);
+
+	rfl = serial_port_in(port, UART_RFL_16550A);
+	while (i < rfl)
+		buf[i++] = serial_port_in(port, UART_RX);
+
+	__dma_rx_complete(p);
+
+	tty_insert_flip_string(tty_port, buf, i);
+	p->port.icount.rx += i;
+	tty_flip_buffer_push(tty_port);
+
+	if (fcr)
+		serial_port_out(port, UART_FCR, p->fcr);
+	return 0;
+}
+
+int serial8250_start_rx_dma(struct uart_8250_port *p)
+{
+	struct uart_8250_dma		*dma = p->dma;
+	struct dma_async_tx_descriptor	*desc;
+
+	desc = dmaengine_prep_dma_cyclic(dma->rxchan, dma->rx_addr,
+					 dma->rx_size, dma->rx_size,
+					 DMA_DEV_TO_MEM, DMA_PREP_INTERRUPT |
+					 DMA_CTRL_ACK);
+	if (!desc)
+		return -EBUSY;
+
+	dma->rx_running = 1;
+	desc->callback = NULL;
+	desc->callback_param = NULL;
+
+	dma->rx_cookie = dmaengine_submit(desc);
+	dma_async_issue_pending(dma->rxchan);
+	dma->rx_index = 0;
+	return 0;
+}
+
+#else
+
 int serial8250_rx_dma(struct uart_8250_port *p, unsigned int iir)
 {
 	struct uart_8250_dma		*dma = p->dma;
@@ -210,11 +326,18 @@ int serial8250_request_dma(struct uart_8250_port *p)
 	dma->rxconf.direction		= DMA_DEV_TO_MEM;
 	dma->rxconf.src_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
 	dma->rxconf.src_addr		= p->port.mapbase + UART_RX;
-
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if ((p->port.fifosize / 4) < 16)
+		dma->rxconf.src_maxburst = p->port.fifosize / 4;
+	else
+		dma->rxconf.src_maxburst = 16;
+#endif
 	dma->txconf.direction		= DMA_MEM_TO_DEV;
 	dma->txconf.dst_addr_width	= DMA_SLAVE_BUSWIDTH_1_BYTE;
 	dma->txconf.dst_addr		= p->port.mapbase + UART_TX;
-
+#ifdef CONFIG_ARCH_ROCKCHIP
+	dma->txconf.dst_maxburst	= 16;
+#endif
 	dma_cap_zero(mask);
 	dma_cap_set(DMA_SLAVE, mask);
 
@@ -227,44 +350,51 @@ int serial8250_request_dma(struct uart_8250_port *p)
 
 	dmaengine_slave_config(dma->rxchan, &dma->rxconf);
 
-	/* Get a channel for TX */
-	dma->txchan = dma_request_slave_channel_compat(mask,
-						       dma->fn, dma->tx_param,
-						       p->port.dev, "tx");
-	if (!dma->txchan) {
-		dma_release_channel(dma->rxchan);
-		return -ENODEV;
-	}
-
-	dmaengine_slave_config(dma->txchan, &dma->txconf);
-
 	/* RX buffer */
+#ifdef CONFIG_ARCH_ROCKCHIP
+	if (!dma->rx_size)
+		dma->rx_size = PAGE_SIZE * 2;
+#else
 	if (!dma->rx_size)
 		dma->rx_size = PAGE_SIZE;
-
+#endif
 	dma->rx_buf = dma_alloc_coherent(dma->rxchan->device->dev, dma->rx_size,
 					&dma->rx_addr, GFP_KERNEL);
 	if (!dma->rx_buf)
-		goto err;
+		goto err_rx;
 
-	/* TX buffer */
-	dma->tx_addr = dma_map_single(dma->txchan->device->dev,
-					p->port.state->xmit.buf,
-					UART_XMIT_SIZE,
-					DMA_TO_DEVICE);
-	if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
-		dma_free_coherent(dma->rxchan->device->dev, dma->rx_size,
-				  dma->rx_buf, dma->rx_addr);
-		goto err;
-	}
+	/* Get a channel for TX */
+	dma->txchan = dma_request_slave_channel_compat(mask,
+						       dma->fn, dma->tx_param,
+						       p->port.dev, "tx");
+	if (dma->txchan) {
+		dmaengine_slave_config(dma->txchan, &dma->txconf);
+
+		/* TX buffer */
+		dma->tx_addr = dma_map_single(dma->txchan->device->dev,
+						p->port.state->xmit.buf,
+						UART_XMIT_SIZE,
+						DMA_TO_DEVICE);
+		if (dma_mapping_error(dma->txchan->device->dev, dma->tx_addr)) {
+			dma_free_coherent(dma->rxchan->device->dev,
+					  dma->rx_size, dma->rx_buf,
+					  dma->rx_addr);
+			dma_release_channel(dma->txchan);
+			dma->txchan = NULL;
+		}
 
-	dev_dbg_ratelimited(p->port.dev, "got both dma channels\n");
+		dev_info_ratelimited(p->port.dev, "got rx and tx dma channels\n");
+	} else {
+		dev_info_ratelimited(p->port.dev, "got rx dma channels only\n");
+	}
 
+#ifdef CONFIG_ARCH_ROCKCHIP
+	/* start dma for rx*/
+	serial8250_start_rx_dma(p);
+#endif
 	return 0;
-err:
+err_rx:
 	dma_release_channel(dma->rxchan);
-	dma_release_channel(dma->txchan);
-
 	return -ENOMEM;
 }
 EXPORT_SYMBOL_GPL(serial8250_request_dma);
@@ -282,15 +412,17 @@ void serial8250_release_dma(struct uart_8250_port *p)
 			  dma->rx_addr);
 	dma_release_channel(dma->rxchan);
 	dma->rxchan = NULL;
+	dma->rx_running = 0;
 
 	/* Release TX resources */
-	dmaengine_terminate_all(dma->txchan);
-	dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
-			 UART_XMIT_SIZE, DMA_TO_DEVICE);
-	dma_release_channel(dma->txchan);
-	dma->txchan = NULL;
-	dma->tx_running = 0;
-
+	if (dma->txchan) {
+		dmaengine_terminate_all(dma->txchan);
+		dma_unmap_single(dma->txchan->device->dev, dma->tx_addr,
+				 UART_XMIT_SIZE, DMA_TO_DEVICE);
+		dma_release_channel(dma->txchan);
+		dma->txchan = NULL;
+		dma->tx_running = 0;
+	}
 	dev_dbg_ratelimited(p->port.dev, "dma channels released\n");
 }
 EXPORT_SYMBOL_GPL(serial8250_release_dma);
